<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bài Thực Hành - Mô Phỏng CPU</title>
  <link rel="stylesheet" href="css/labs.css">
</head>

<body>

  <div class="container">
    <h1>Bài thực hành Thiết kế và Mô phỏng Mạch Kiến trúc Máy tính - CircuitVerse</h1>
    <p>
      Các bài thực hành sau đây giúp sinh viên hiểu rõ về cấu trúc và hoạt động của CPU thông qua các mô phỏng
      trực quan trên nền tảng web. Trình mô phỏng CircuitVerse cho phép sinh viên khám phá các thành phần trong
      CPU MIPS, như bộ điều khiển, ALU, bộ thanh ghi, bộ nhớ và bus dữ liệu, thông qua sơ đồ mạch logic, từ đó
      nắm vững cách các thành phần này phối hợp và dữ liệu di chuyển trong quá trình thực thi.
    </p>


    <h2>Bài 1-1: Mạch logic cơ bản & Bảng chân trị</h2>
    <div class="note-box">
      <h4>Mục tiêu</h4>
      <ol>
        <li>Nhận biết AND, OR, NOT, XOR, NAND, NOR, XNOR.</li>
        <li>Tạo bảng chân trị 2 ngõ vào (4 tổ hợp).</li>
        <li>Đo kiểm bằng LED/Probe và chụp hình.</li>
      </ol>

      <h4>Công cụ & Chuẩn bị</h4>
      <ol>
        <li>Tài khoản circuitverse.org; trình duyệt Chrome/Microsoft Edge/Firefox/Cốc Cốc.</li>
        <li>Thư viện: Gates (AND/OR/NOT/XOR/…), Input/Output (Switch, LED).</li>
      </ol>

      <h4>Hướng dẫn thực hiện</h4>
      <ol>
        <li>New Project → đặt tên “CV01_Logic”.</li>
        <li>Thêm 2 Switch (A,B) và 1 LED (Y).</li>
        <li>Nối A,B → AND → Y. Bật lần lượt 00, 01, 10, 11; ghi kết quả.</li>
        <li>Lặp lại cho OR, XOR; với NOT dùng 1 ngõ A.</li>
        <li>Thêm nhãn (Text) các bảng chân trị; Save → Share → Public link.</li>
      </ol>

      <h4>Yêu cầu nộp</h4>
      <ol>
        <li>Ảnh mạch AND/OR/XOR/NOT.</li>
        <li>Bảng chân trị điền đủ 4 tổ hợp cho từng cổng.</li>
        <li>Public link dự án.</li>
      </ol>

      <h4>Câu hỏi ôn tập</h4>
      <ol>
        <li>Khác nhau OR và XOR trên bảng chân trị?</li>
        <li>Tạo NAND từ AND và NOT như thế nào (biểu thức)?</li>
      </ol>
    </div>

    <h2>Bài 1-2: Foll Adder 1-bit & Bộ cộng 4-bit (Ripple Carry Adder)</h2>

    <div class="note-box">
      <h4>Mục tiêu</h4>
      <ol>
        <li>Thiết kế Half Adder (HA) và Foll Adder (FA) 1-bit.</li>
        <li>Ghép 4 FA thành bộ cộng 4-bit dạng Ripple Carry.</li>
        <li>Kiểm thử hoạt động với Cin.</li>
      </ol>

      <h4>Công cụ & Chuẩn bị</h4>
      <ol>
        <li>Các cổng XOR / AND / OR.</li>
        <li>Hex Display hoặc LED.</li>
        <li>Kỹ thuật Subcircuit trong CircuitVerse.</li>
      </ol>

      <h4>Hướng dẫn thực hiện</h4>
      <ol>
        <li>Half Adder: Sum = A XOR B; Carry = A AND B.</li>
        <li>Foll Adder: Sum = A XOR B XOR Cin; Cout = (A & B) OR (Cin & (A XOR B)).</li>
        <li>Tạo subcircuit “FA_1bit”, ghép 4 cái → “Adder_4bit”, nối Cout → Cin kế tiếp.</li>
        <li>Thêm A[3:0], B[3:0] (Input 4-bit), Cin (1-bit); dùng Splitter/Combiner khi cần.</li>
        <li>Test 1: A = 0011, B = 0101, Cin = 0 → Sum = 1000, Cout = 0.</li>
        <li>Test 2: A = 1111, B = 0001, Cin = 1 → Sum = 0001, Cout = 1.</li>
      </ol>

      <h4>Yêu cầu nộp</h4>
      <ol>
        <li>Ảnh mạch HA, FA, Adder_4bit + Public link.</li>
        <li>Bảng kết quả của 2 test.</li>
      </ol>

      <h4>Câu hỏi ôn tập</h4>
      <ol>
        <li>Vì sao có trễ truyền carry (ripple)?</li>
        <li>Nêu ý tưởng Carry Lookahead.</li>
      </ol>

      <h4>Tham khảo</h4>
      <ol>
        <li><strong>Half Adder:</strong> Cộng hai bit A, B → tạo Sum và Carry. Không xử lý Cin.
          <p>
            Mạch Half Adder (Bộ cộng bán phần) là một mạch logic thực hiện phép cộng hai bit đầu vào: A và B. Bộ cộng
            bán phần cho ra hai đầu ra gồm: Sum (Tổng) và Carry (bit nhớ). Tuy nhiên, Half Adder không xử lý được bit
            nhớ từ phép cộng trước đó, vì vậy nó chỉ dùng trong các phép cộng đơn bit hoặc làm thành phần cơ bản để
            xây dựng bộ cộng toàn phần (Foll Adder).
          </p>
          <div class="image-container">
            <img src="images/half-adder.png" class="responsive-img1">
          </div>
        </li>

        <li><strong>Foll Adder:</strong> Cộng A, B, Cin → tạo Sum và Cout để truyền sang tầng kế tiếp.
          <p>Mạch Foll Adder (Bộ cộng toàn phần) là một mạch logic thực hiện phép cộng ba bit đầu vào: A, B và
            Carry-in (Cin) từ bộ cộng trước đó. Đầu ra của nó là Sum (Tổng) và Carry-out (Cout) để truyền sang
            bộ cộng tiếp theo.
            Đây là sơ đồ mạch logic cơ bản của một Foll Adder:
          </p>
          <div class="image-container">
            <img src="images/foll-adder.png" class="responsive-img1">
          </div>
        </li>
        <li><strong>Ripple Carry 4-bit:</strong> Ghép 4 FA nối tiếp; Cout của FA trước → Cin của FA sau.
          <p>Bộ cộng Ripple Carry 4-bit được tạo bằng cách nối tiếp bốn bộ Foll Adder 1-bit. Bit nhớ đầu ra
            (Cout) của mỗi bộ Foll Adder sẽ là bit nhớ đầu vào (Cin) cho bộ Foll Adder tiếp theo (từ bit có
            trọng số thấp nhất LSB đến bit có trọng số cao nhất MSB).
          </p>
          <div class="image-container">
            <img src="images/ripple-carry-adder.png" class="responsive-img1">
          </div>
          <h4>Giải thích</h4>
          <p>
            Mạch cộng 4-bit Ripple Carry Adder là một mạch cộng nhị phân gồm 4 bộ cộng toàn phần (Foll Adder) mắc
            nối tiếp, mỗi bộ chịu trách nhiệm cộng một cặp bit ở cùng vị trí (X₀–X₃ và Y₀–Y₃). Các bộ cộng được
            ghép theo chuỗi sao cho Carry-out của bộ cộng bậc thấp hơn sẽ được truyền vào Carry-in của bộ cộng
            bậc cao hơn. Vì bit nhớ này lan truyền (“ripple”) qua từng tầng, mạch có tên là Ripple Carry.
          </p>
          <h4>Cấu trúc hoạt động</h4>
          <ol>
            <li> FA₀ xử lý bit thấp nhất (LSB): X₀, Y₀ và Cin₀ → tạo ra S₀ và Cout₀</li>
            <li>Cout₀ được đưa sang Cin₁ của FA₁</li>
            <li>Quá trình tiếp tục qua FA₂ và FA₃</li>
            <li>Bộ cộng cuối (FA₃) tạo ra S₃ và Cout₃ (bit nhớ cuối – MSB)</li>
          </ol>
        </li>
      </ol>
    </div>

    <h2>Bài 1-3: Thanh ghi 4-bit bằng D Flip-Flop (có Load đúng kỹ thuật)</h2>
<div class="note-box">
  <h4>Mục tiêu</h4>
  <ol>
    <li>Xây thanh ghi 4-bit với MUX 2:1 + DFF (giữ khi Load = 0).</li>
    <li>Dùng Splitter/Combiner đúng bit-width cho bus 4-bit.</li>
    <li>Kiểm thử hoạt động ghi và giữ dữ liệu của thanh ghi.</li>
  </ol>

  <h4>Công cụ & Chuẩn bị</h4>
  <ol>
    <li>Sequential: DFF, Clock.</li>
    <li>Decoders & Plexers: MUX 2:1.</li>
    <li>I/O: Splitter, Combiner, Hex Display.</li>
  </ol>

  <h4>Hướng dẫn thực hiện</h4>
  <ol>
    <li>Nối W-data[3:0] → Splitter (In = 4, Out = 1, FanOut = 4) → tách thành W0, W1, W2, W3.</li>
    <li>Với mỗi bit i: MUX 2:1 (In0 ← Qi, In1 ← W[i], S ← Load) → DFF → Qi; tất cả DFF dùng chung một Clock (khoảng 1 Hz).</li>
    <li>Nối Q0..Q3 → Combiner → Q-bus[3:0] → Hex Display để hiển thị giá trị thanh ghi.</li>
    <li>Test A: Đặt W = 1010, Load = 1, nhấn một xung Clock → kiểm tra Q = 1010.</li>
    <li>Test B: Đặt W = 0101, Load = 0, nhấn một xung Clock → kiểm tra Q vẫn giữ 1010.</li>
    <li>Test C: Giữ W = 0101, đặt Load = 1, nhấn một xung Clock → kiểm tra Q = 0101.</li>
  </ol>

  <h4>Yêu cầu nộp</h4>
  <ol>
    <li>Ảnh mạch thanh ghi 4-bit hoàn chỉnh.</li>
    <li>Ảnh kết quả của 3 test (A, B, C) thể hiện rõ W, Load, Q/Hex Display.</li>
    <li>Public link mạch (nếu làm trên nền tảng online).</li>
    <li>Bảng log giá trị Q qua từng bước (trước và sau mỗi xung Clock cho từng test).</li>
  </ol>

  <h4>Câu hỏi ôn tập</h4>
  <ol>
    <li>Vì sao gating bằng AND trước chân D là sai về mặt kỹ thuật thiết kế mạch tuần tự?</li>
    <li>Viết biểu thức D_next cho mỗi bit khi Load = 0 và khi Load = 1 (sau đó rút gọn thành một biểu thức logic duy nhất).</li>
  </ol>
</div>

<h2>Bài 1-4: ALU 4-bit (ADD, SUB, AND, OR) + MUX chọn chức năng</h2>
<div class="note-box">

  <h4>Mục tiêu</h4>
  <ol>
    <li>Xây 4 khối: ADD, SUB (A + ~B + 1), AND, OR.</li>
    <li>Dùng MUX 4→1 (bus) theo Op[1:0].</li>
    <li>Tạo cờ Zero và Carry.</li>
  </ol>

  <h4>Công cụ & Chuẩn bị</h4>
  <ol>
    <li>Adder_4bit (CV-02), MUX bus.</li>
    <li>Các cổng logic (AND, OR, NOT).</li>
    <li>Hex Display để quan sát kết quả.</li>
  </ol>

  <h4>Hướng dẫn</h4>
  <ol>
    <li>Dựng 4 khối chức năng: ADD; SUB = A + (~B) + 1; AND; OR.</li>
    <li>Dùng MUX 4→1 (bus) để chọn kết quả theo Op = 00 / 01 / 10 / 11.</li>
    <li>Zero = (Resolt == 0000); Carry lấy từ khối Adder.</li>
    <li>Test: A = 1001, B = 0011 ở cả 4 Op; ghi lại Resolt, Carry, Zero.</li>
  </ol>

  <h4>Yêu cầu nộp</h4>
  <ol>
    <li>Ảnh mạch ALU hoàn chỉnh.</li>
    <li>Bảng kết quả cho 4 phép toán.</li>
    <li>Public link dự án.</li>
  </ol>

  <h4>Câu hỏi ôn tập</h4>
  <ol>
    <li>Tại sao SUB = A + ~B + 1?</li>
    <li>Nếu thêm XOR, cần thay đổi gì trong MUX hoặc thiết kế?</li>
  </ol>

</div>

<h2>Bài 1-5: CPU mini – Register File 4×4-bit (2R1W) + ALU + Control</h2>
<div class="note-box">

  <h4>Mục tiêu</h4>
  <ol>
    <li>Ghép Register File (xx chọn ghi; yy/zz chọn đọc) với ALU.</li>
    <li>Chạy chuỗi thao tác ghi, đọc và tính toán.</li>
    <li>Ghi log giá trị các thanh ghi theo thời gian.</li>
  </ol>

  <h4>Công cụ & Chuẩn bị</h4>
  <ol>
    <li>Decoder 2→4 (xx) để chọn thanh ghi ghi.</li>
    <li>MUX 4→1 cho yy và zz để chọn 2 cổng đọc.</li>
    <li>4 thanh ghi 4-bit (CV-03).</li>
    <li>ALU 4-bit (CV-04).</li>
  </ol>

  <h4>Hướng dẫn thực hiện</h4>
  <ol>
    <li>Dựng Register File 4×4: W-data cấp song song; Decoder(xx) → Load_Ra..Rd; yy → MUX → RA; zz → MUX → RB.</li>
    <li>Đưa RA và RB vào ALU; Resolt quay lại W-data; dùng xx để chọn thanh ghi đích cần ghi.</li>
    <li>Chuỗi thao tác:</li>
    <ol>
      <li>B1) W = 0001, xx = 10 (ghi Rc), nhấn Clock → Rc = 0001.</li>
      <li>B2) Op = ADD, yy = 10 (Rc), zz = 00 (Ra), ghi kết quả về Rd.</li>
      <li>B3) Thử SUB / AND / OR và quan sát sự thay đổi của Ra..Rd.</li>
    </ol>
  </ol>

  <h4>Yêu cầu nộp</h4>
  <ol>
    <li>Ảnh sơ đồ CPU mini.</li>
    <li>Bảng log giá trị Ra..Rd theo thời gian (sau từng bước B1–B3).</li>
    <li>Public link dự án.</li>
  </ol>

  <h4>Câu hỏi ôn tập</h4>
  <ol>
    <li>Nguy cơ Hazard nếu thêm pipeline?</li>
    <li>Làm thế nào để mở rộng lên 8 thanh ghi và hỗ trợ 2 cổng ghi?</li>
  </ol>

</div>

    <a href="MoPhongThucHanhKTMT.html" class="back-button">← Quay lại Trang chủ</a>
  </div>

</body>

</html>